/*
 * Copyright (C) 2023 Tony Luken <tonyluken62+gerberfileparser.gmail.com>
 * 
 * This file is part of GerberFileParser.
 * 
 * GerberFileParser is free software: you can redistribute it and/or modify it under the terms of 
 * the GNU General Public License as published by the Free Software Foundation, either version 3 of 
 * the License, or (at your option) any later version.
 * 
 * GerberFileParser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with GerberFileParser. If
 * not, see <http://www.gnu.org/licenses/>.
 */

package GerberFileParser;

import java.awt.BasicStroke;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.Area;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import GerberFileParser.StrokeInfo;
import GerberFileParser.Utils.ArcParameters;

/**
 * A class to represent a Gerber Aperture
 * 
 * @see <a href="https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-
 * specification-revision-2022-02_en.pdf?ac97011bf6bce9aaf0b1aac43d84b05f#page=48">
 * Section 4.3 of the Gerber Layer Format Specification</a>
 */
public class Aperture extends GraphicsStream {
    protected ApertureType type;
    protected String id;
    
    /**
     * Default constructor
     */
    Aperture() {
        
    }
    
    /**
     * Parses the Aperture Definition command (see section 4.3.1) and constructs the new aperture by 
     * finding the requested template name in the aperture template dictionary, instantiating the 
     * template, and attaching all aperture attributes contained in the attribute dictionary.
     * 
     * @param command - an Aperture Definition command, such as: "ADD10C,.025"
     * @param templateDictionary - the template dictionary
     * @param attributeDictionary - the attribute dictionary
     * @throws Exception if the command passed does not begin with "AD" or if the aperture id is not 
     * valid or if the requested aperture template is not found in the template dictionary
     */
    Aperture(String command, ApertureTemplateDictionary templateDictionary, 
            AttributeDictionary attributeDictionary) throws Exception {
        String cmd = command.substring(0, 2);
        if (!cmd.equals("AD")) {
            throw new Exception("Aperture must be defined with an AD command but found: " + command);
        }
        int ne = Utils.numberEndIndex(command, 3);
        if (command.charAt(2) != 'D' || ne < 0) {
            throw new Exception("Aperture id not valid: " + command);
        }
        id = command.substring(3, ne);
        String templateName;
        int te = command.indexOf(",");
        if (te != -1) {
            templateName = command.substring(ne, te);
        }
        else {
            templateName = command.substring(ne);            
        }
        ApertureTemplate template = templateDictionary.get(templateName);
        if (template == null) {
            throw new Exception("Aperture template name '" + templateName
                    + "' not found in aperture template dictionary");
        }
        type = template.getType();
        List<Double> params = new ArrayList<>();
        if (te != -1) {
            StringTokenizer st = new StringTokenizer(command.substring(te+1), "X");
            while (st.hasMoreTokens()) {
                params.add(Double.parseDouble(st.nextToken()));
            }
        }
        put(template.instantiate(params, attributeDictionary.getAllOf(AttributeType.Aperture)));
    }
    
    /**
     * 
     * @return the type of the aperture
     */
    public ApertureType getType() {
        return type;
    }
    
    /**
     * 
     * @return the id of the aperture
     */
    public String getId() {
        return id;
    }
    
    /**
     * Plots either a linear or a circular stroke (depending on the current graphic state) using 
     * this aperture as a pen. The resulting graphic object has the aperture's attributes attached 
     * to it as well as any object attributes that are currently in the attribute dictionary.
     * 
     * @param graphicState - the current graphic state (see section 2.6)
     * @param newPoint - the end point of the stroke
     * @param attributeDictionary - the attribute dictionary
     * @return a GraphicStream containing the GraphicObject generated by the stroke
     * @throws Exception if an aperture other than a Circle is used to stroke an arc or if an
     * aperture other than a Circle or a Rectangle is used to stroke a linear segment.
     */
    public GraphicsStream plot(GraphicsState graphicState, Point newPoint, 
            AttributeDictionary attributeDictionary) throws Exception {
        AttributeDictionary objAtt = new AttributeDictionary();
        for (GraphicalObject go : getStream()) {
            objAtt.putAll(go.getAttributes());
        }
        objAtt.putAll(attributeDictionary.getAllOf(AttributeType.Object));

        Rectangle2D bounds = getStream().get(0).getArea().getBounds2D();
        Point currentPoint = graphicState.getCurrentPoint();
        GraphicsStream ret = new GraphicsStream();
        if (graphicState.getPlotState() == PlotState.Linear) {
            Shape stroke = new Line2D.Double(currentPoint.x, currentPoint.y, newPoint.x, newPoint.y);
            MetaData metaData = new MetaData(new StrokeInfo(new Path2D.Double(stroke)));
            if (getType() == ApertureType.Circle) {
                double diam = Math.max(bounds.getWidth() * graphicState.getApertureTransformation()
                        .getScale(), 1e-7);
                BasicStroke s1 = new BasicStroke((float) diam, BasicStroke.CAP_ROUND, 
                        BasicStroke.JOIN_ROUND);
                Shape shape = s1.createStrokedShape(stroke);
                ret.put(new GraphicalObject(new Area(shape), graphicState
                        .getApertureTransformation().getPolarity(), objAtt, metaData));
            }
            else if (getType() == ApertureType.Rectangle) {
                double width = bounds.getWidth();
                double height = bounds.getHeight();
                double[] cornerPoints = new double[] {
                        -width/2, -height/2,
                        -width/2,  height/2, 
                         width/2,  height/2, 
                         width/2, -height/2};
                double[] cornerPoints1 = new double[8];
                double[] cornerPoints2 = new double[8];
                AffineTransform at1 = new AffineTransform();
                at1.translate(currentPoint.x, currentPoint.y);
                at1.concatenate(graphicState.getApertureTransformation().getApertureTransform());
                at1.transform(cornerPoints, 0, cornerPoints1, 0, 4);
                AffineTransform at2 = new AffineTransform();
                at2.translate(newPoint.x, newPoint.y);
                at2.concatenate(graphicState.getApertureTransformation().getApertureTransform());
                at2.transform(cornerPoints, 0, cornerPoints2, 0, 4);
                //Equation of line through the given end points is a*x + b*y + c = 0 where:
                double a = currentPoint.y - newPoint.y;
                double b = newPoint.x - currentPoint.x;
                double c = newPoint.y*(currentPoint.x - newPoint.x) - 
                        newPoint.x*(currentPoint.y - newPoint.y);
                //Figure out which corners of the rectangle are farthest from the line, these set 
                //the side of the stroke
                double n1 = Math.abs(a*cornerPoints1[0] + b*cornerPoints1[1] + c);
                double n2 = Math.abs(a*cornerPoints1[2] + b*cornerPoints1[3] + c);
                Path2D.Double path = new Path2D.Double();
                if (n1 >= n2) {
                    //0 and 2 are the farthest from the line
                    //Now figure out which of the other corners is farthest from the opposite end
                    if (Math.hypot(cornerPoints1[2]-newPoint.x, cornerPoints1[3]-newPoint.y) >= 
                            Math.hypot(cornerPoints1[6]-newPoint.x, cornerPoints1[7]-newPoint.y)) {
                        //1 is the farthest from the other end, so we go s1, s0, e0, e3, e2, s2, s1
                        path.moveTo(cornerPoints1[2], cornerPoints1[3]);
                        path.lineTo(cornerPoints1[0], cornerPoints1[1]);
                        path.lineTo(cornerPoints2[0], cornerPoints2[1]);
                        path.lineTo(cornerPoints2[6], cornerPoints2[7]);
                        path.lineTo(cornerPoints2[4], cornerPoints2[5]);
                        path.lineTo(cornerPoints1[4], cornerPoints1[5]);
                    }
                    else {
                        //3 is the farthest from the other end, so we go s3, s0, e0, e1, e2, s2, s3 
                        path.moveTo(cornerPoints1[6], cornerPoints1[7]);
                        path.lineTo(cornerPoints1[0], cornerPoints1[1]);
                        path.lineTo(cornerPoints2[0], cornerPoints2[1]);
                        path.lineTo(cornerPoints2[2], cornerPoints2[3]);
                        path.lineTo(cornerPoints2[4], cornerPoints2[5]);
                        path.lineTo(cornerPoints1[4], cornerPoints1[5]);
                    }
                }
                else {
                    //1 and 3 are the farthest from the line
                    //Now figure out which of the other corners is farthest from the opposite end
                    if (Math.hypot(cornerPoints1[0]-newPoint.x, cornerPoints1[1]-newPoint.y) >= 
                            Math.hypot(cornerPoints1[4]-newPoint.x, cornerPoints1[5]-newPoint.y)) {
                        //0 is the farthest from the other end, so we go s0, s1, e1, e2, e3, s3, s0
                        path.moveTo(cornerPoints1[0], cornerPoints1[1]);
                        path.lineTo(cornerPoints1[2], cornerPoints1[3]);
                        path.lineTo(cornerPoints2[2], cornerPoints2[3]);
                        path.lineTo(cornerPoints2[4], cornerPoints2[5]);
                        path.lineTo(cornerPoints2[6], cornerPoints2[7]);
                        path.lineTo(cornerPoints1[6], cornerPoints1[7]);
                    }
                    else {
                        //2 is the farthest from the other end, so we go s2, s1, e1, e0, e3, s3, s2
                        path.moveTo(cornerPoints1[4], cornerPoints1[5]);
                        path.lineTo(cornerPoints1[2], cornerPoints1[3]);
                        path.lineTo(cornerPoints2[2], cornerPoints2[3]);
                        path.lineTo(cornerPoints2[0], cornerPoints2[1]);
                        path.lineTo(cornerPoints2[6], cornerPoints2[7]);
                        path.lineTo(cornerPoints1[6], cornerPoints1[7]);
                    }
                }
                path.closePath();
                ret.put(new GraphicalObject(new Area(path), 
                        graphicState.getApertureTransformation().getPolarity(), objAtt, metaData));
                }
            else {
                throw new Exception("Plotting lines with " + getType() + 
                        " apertures is not supported");
            }
        }
        else {
            if (getType() != ApertureType.Circle) {
                throw new Exception("Plotting arcs with " + getType() + 
                        " apertures is not supported");
            }
            
            ArcParameters arcParams = Utils.computeArcParameters(graphicState, newPoint);
            if (arcParams.extentAngleDeg == 0) {
                return flash(graphicState, newPoint, attributeDictionary);
            }
            Shape stroke = new Arc2D.Double(arcParams.center.x - arcParams.radius,
                    arcParams.center.y - arcParams.radius, 
                    2*arcParams.radius, 2*arcParams.radius, arcParams.startAngleDeg, 
                    arcParams.extentAngleDeg, Arc2D.OPEN);
            MetaData metaData = new MetaData(new StrokeInfo(new Path2D.Double(stroke)));
            // Stroke the arc
            double diam = bounds.getWidth() * graphicState.getApertureTransformation().getScale();
            BasicStroke s1 = new BasicStroke((float) diam, BasicStroke.CAP_ROUND, 
                    BasicStroke.JOIN_ROUND);
            Shape shape = s1.createStrokedShape(stroke);
            ret.put(new GraphicalObject(new Area(shape), 
                    graphicState.getApertureTransformation().getPolarity(), objAtt, metaData));
        }

        return ret;
    }
    
    /**
     * Generates a graphic object by applying the aperture transformations that are currently in 
     * effect to this aperture. The resulting graphic object is translated to the flashPoint and
     * has the aperture's attributes attached to it as well as any object attributes that are 
     * currently in the attribute dictionary.
     * 
     * @param graphicState - the current graphic state (see section 2.6)
     * @param flashPoint - the location of the flash
     * @param attributeDictionary - the attribute dictionary
     * @return a GraphicStream containing the GraphicObject generated by the flash
     * @throws Exception if the aperture transformation has not been set
     */
    public GraphicsStream flash(GraphicsState graphicState, Point flashPoint, 
            AttributeDictionary attributeDictionary) throws Exception {
        return graphicState.getApertureTransformation().apply(flashPoint, this, attributeDictionary);
    }
}
