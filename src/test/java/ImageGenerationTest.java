import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.io.File;
import javax.imageio.ImageIO;
import org.junit.jupiter.api.Test;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Rect;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

import GerberFileParser.GerberFileParser;
import GerberFileParser.GraphicalObject;
import GerberFileParser.GraphicsStream;
import GerberFileParser.Polarity;

public class ImageGenerationTest {
    static {
        nu.pattern.OpenCV.loadLocally();
    }

    private final static boolean DEBUG = false;
    private final static double ASPECT_RATIO_TOLERANCE = 0.007;
    private final static int EROSION_KERNEL_SIZE = 5; //needs to be an odd positive integer
    private Exception savedError = null;
    
    /**
     * This test generates images from a set of Gerber files and compares them to screen captures of
     * images generated by Ucamco's web based Reference Gerber Viewer.
     * 
     * @throws Exception if there is a problem reading the files or if the images miscompare.
     */
    @Test
    public void testImageGeneration() throws Exception {
        File testFileDir = new File(ClassLoader.getSystemResource("gerberFiles").getPath());
        File expectedDir = new File(ClassLoader.getSystemResource("expectedResults").getPath());
        File[] files = testFileDir.listFiles();
        for (File testFile : files) {
            if (testFile.isDirectory()) {
                continue;
            }
            System.out.println(testFile);
            String expectedName = testFile.getName().substring(0, testFile.getName().length()-3) + "png";
            File expectedFile = new File(expectedDir + File.separator + expectedName);
            if (!testFile.exists() || !expectedFile.exists()) {
                continue;
            }
            GerberFileParser parser = new GerberFileParser(testFile);
            parser.parseFileInBackground(null, null, (ex)->savedError=ex);
            
            System.out.println(expectedFile);
            BufferedImage expectedImage = ImageIO.read(expectedFile);

            Mat expectedImageMat = bufferedImageToMat(expectedImage);

            //Wait for the parser to finish
            while (!parser.isDone() && !parser.isError()) {};
            
            if (parser.isError()) {
                savedError.printStackTrace();
                throw new Exception(savedError.getMessage());
            }
            
            BufferedImage gerberImage = renderGerberImage(parser.getImageGraphicStream(), 
                    expectedImageMat.size(), Imgproc.boundingRect(expectedImageMat));
            
            Mat gerberImageMat = bufferedImageToMat(gerberImage);
            
            Mat comparisonImageMat = new Mat();
            
            //Generate an image that has pixels set wherever the two images differ
            Core.bitwise_xor(expectedImageMat, gerberImageMat, comparisonImageMat);
            
            //Since the expected image is a screen capture from a web page, it probably has a 
            //different resolution/anti-aliasing than the image generated by renderGerberImage. 
            //Therefore we can't expect the two images to be exactly the same. So for comparison 
            //purposes, we need to ignore any small differences that occur around the edges of 
            //objects. We do that by eroding the difference image by a few pixels.
            Mat erodedImageMat = new Mat();
            Mat element = Imgproc.getStructuringElement(Imgproc.CV_SHAPE_RECT, 
                    new Size(EROSION_KERNEL_SIZE, EROSION_KERNEL_SIZE));
            Imgproc.erode(comparisonImageMat, erodedImageMat, element);
            
            //Finally we count all the remaining non-zero pixels to determine if the images are
            //really different
            int differentPixelCount = Core.countNonZero(erodedImageMat);

            if (differentPixelCount > 0) {
                if (DEBUG) {
                    //Save the images in the system's default temp directory for later analysis
                    String tempDirName = System.getProperty("java.io.tmpdir");
                    File outFile = new File(tempDirName + File.separator + "expectedImage.png");
                    ImageIO.write(expectedImage, "png", outFile);
                    outFile = new File(tempDirName + File.separator + "testImage.png");
                    ImageIO.write(gerberImage, "png", outFile);
                    outFile = new File(tempDirName + File.separator + "comparisonImage.png");
                    ImageIO.write(matToBufferedImage(comparisonImageMat), "png", outFile);
                    outFile = new File(tempDirName + File.separator + "erodedImage.png");
                    ImageIO.write(matToBufferedImage(erodedImageMat), "png", outFile);
                }
                throw new Exception("Images failed to compare, number of different pixels = " + differentPixelCount);
            }
            else {
                System.out.println("Images compared successfully");
            }
            
            expectedImageMat.release();
            gerberImageMat.release();
            comparisonImageMat.release();
            erodedImageMat.release();
            
        }
        System.out.println("All images compared successfully!");
    }
    
    private static Mat bufferedImageToMat(BufferedImage bi) {
        Mat mat = new Mat(bi.getHeight(), bi.getWidth(), CvType.CV_8UC3);
        byte[] data = ((DataBufferByte) bi.getRaster().getDataBuffer()).getData();
        mat.put(0, 0, data);
        Imgproc.cvtColor(mat, mat, Imgproc.COLOR_RGB2GRAY);
        Imgproc.threshold(mat, mat, 50, 255, Imgproc.THRESH_BINARY);
        return mat;
    }
    
    private static BufferedImage matToBufferedImage(Mat mat) {
        BufferedImage gray = new BufferedImage(mat.width(), mat.height(), BufferedImage.TYPE_BYTE_GRAY);
        byte[] data = ((DataBufferByte) gray.getRaster().getDataBuffer()).getData();
        mat.get(0, 0, data);
        return gray;
    }
    
    private static BufferedImage renderGerberImage(GraphicsStream gs, Size imageSize, Rect brTo) throws Exception {
        //Get the bounds of all objects in the test image
        Rectangle2D brFrom = gs.getBounds();
        
        //Check to make sure the aspect ratios of the objects in the expected image and the test
        //image are nearly the same
        double aspectRatioRatio = brTo.width*brFrom.getHeight()/(brTo.height*brFrom.getWidth());
        if (Math.abs(aspectRatioRatio - 1) > ASPECT_RATIO_TOLERANCE) {
            throw new Exception("Aspect ratios are too different: " + Math.abs(aspectRatioRatio - 1));
        }
        
        //Create the test image
        BufferedImage gerberImage = new BufferedImage((int) imageSize.width, 
                (int) imageSize.height, BufferedImage.TYPE_3BYTE_BGR);
        Graphics2D offScr = (Graphics2D) gerberImage.getGraphics();
        offScr.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        Color background = Color.BLACK;
        Color foreground = Color.WHITE;
        
        //Fill the entire image with the background color
        offScr.setColor(background);
        offScr.fillRect(0, 0, (int) imageSize.width, (int) imageSize.height);
        
        //Set the translation and scaling so that when the Gerber objects get plotted onto the test 
        //image, they fall at the same pixel coordinates as the objects in the expected image. Note
        //that Gerber objects follow the Gerber convention of the X-axis increasing to the right and 
        //the Y-axis increasing upwards while the Java standard for images has the X-axis increasing
        //to the right and the Y-axis increasing downwards. Basically this maps the lower left 
        //corner of Gerber objects' bounding box [brFrom.x, brFrom.y] to the lower left corner of 
        //the expected image objects' bounding box [brTo.x, brTo.y+brTo.height] and the upper right 
        //corner of the Gerber objects' bounding box [brFrom.x+brFrom.width, brFrom.y+brFrom.height] 
        //to the upper right corner of the expected image objects' bounding box [brTo.x+brTo.width, 
        //brTo.y].
        offScr.translate(brTo.x - brFrom.getX()*brTo.width/brFrom.getWidth(), 
                brTo.y + brTo.height + brFrom.getY()*brTo.height/brFrom.getHeight());
        offScr.scale(brTo.width/brFrom.getWidth(), -brTo.height/brFrom.getHeight());
        
        //Plot all the Gerber graphical objects onto the image
        for (GraphicalObject go : gs.getStream()) {
            if (go.getPolarity() == Polarity.Dark) {
                offScr.setColor(foreground);
            }
            else { //Polarity.Clear
                offScr.setColor(background);
            }
            offScr.fill(go.getArea());
        }
        
        offScr.dispose();
        
        return gerberImage;
    }
}
